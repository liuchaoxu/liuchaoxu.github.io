import{_ as o,D as r,c as n,I as s,w as i,a,j as e,a4 as l,o as c}from"./chunks/framework.DQPzzBi7.js";const De=JSON.parse('{"title":"Java开发规范","titleTemplate":"规范","description":"java","frontmatter":{"layout":"doc","lang":"zh-CN","title":"Java开发规范","titleTemplate":"规范","description":"java","sidebar":true,"aside":true,"outline":[1,2,3,4,5,6],"lastUpdated":false,"prev":{"text":"知识地图","link":"/docs/知识地图"},"next":false,"footer":false},"headers":[],"relativePath":"docs/Java/Java后端开发规范.md","filePath":"docs/Java/Java后端开发规范.md","lastUpdated":1744037383000}'),h={name:"docs/Java/Java后端开发规范.md"},d=l("",4),p=e("h3",{id:"_2-方法名、参数名、成员变量、局部变量都统一使用lowercamelcase风格-必须遵从-驼峰形式。",tabindex:"-1"},[a("2.方法名、参数名、成员变量、局部变量都统一使用lowerCamelCase风格，必须遵从 驼峰形式。 "),e("a",{class:"header-anchor",href:"#_2-方法名、参数名、成员变量、局部变量都统一使用lowercamelcase风格-必须遵从-驼峰形式。","aria-label":'Permalink to "2.方法名、参数名、成员变量、局部变量都统一使用lowerCamelCase风格，必须遵从 驼峰形式。"'},"​")],-1),_=e("h3",{id:"_3-常量命名全部大写-单词间用下划线隔开-力求语义表达完整清楚-不要嫌名字长。",tabindex:"-1"},[a("3.常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。 "),e("a",{class:"header-anchor",href:"#_3-常量命名全部大写-单词间用下划线隔开-力求语义表达完整清楚-不要嫌名字长。","aria-label":'Permalink to "3.常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。"'},"​")],-1),u=e("h3",{id:"_4-抽象类命名使用abstract或base开头-异常类命名使用exception结尾-测试类-命名以它要测试的类的名称开始-以test结尾。",tabindex:"-1"},[a("4. 抽象类命名使用Abstract或Base开头；异常类命名使用Exception结尾；测试类 命名以它要测试的类的名称开始，以Test结尾。 "),e("a",{class:"header-anchor",href:"#_4-抽象类命名使用abstract或base开头-异常类命名使用exception结尾-测试类-命名以它要测试的类的名称开始-以test结尾。","aria-label":'Permalink to "4. 抽象类命名使用Abstract或Base开头；异常类命名使用Exception结尾；测试类 命名以它要测试的类的名称开始，以Test结尾。"'},"​")],-1),m=e("h3",{id:"_5-中括号是数组类型的一部分-数组定义如下-string-args",tabindex:"-1"},[a("5. 中括号是数组类型的一部分，数组定义如下：String[] args; "),e("a",{class:"header-anchor",href:"#_5-中括号是数组类型的一部分-数组定义如下-string-args","aria-label":'Permalink to "5. 中括号是数组类型的一部分，数组定义如下：String[] args;"'},"​")],-1),b=e("h3",{id:"_6-pojo类中布尔类型的变量-都不要加is-否则部分框架解析会引起序列化错误。",tabindex:"-1"},[a("6. POJO类中布尔类型的变量，都不要加is，否则部分框架解析会引起序列化错误。 "),e("a",{class:"header-anchor",href:"#_6-pojo类中布尔类型的变量-都不要加is-否则部分框架解析会引起序列化错误。","aria-label":'Permalink to "6. POJO类中布尔类型的变量，都不要加is，否则部分框架解析会引起序列化错误。"'},"​")],-1),y=e("h3",{id:"_7-包名统一使用小写-点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用-单数形式-但是类名如果有复数含义-类名可以使用复数形式。",tabindex:"-1"},[a("7. 包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用 单数形式，但是类名如果有复数含义，类名可以使用复数形式。 "),e("a",{class:"header-anchor",href:"#_7-包名统一使用小写-点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用-单数形式-但是类名如果有复数含义-类名可以使用复数形式。","aria-label":'Permalink to "7. 包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用 单数形式，但是类名如果有复数含义，类名可以使用复数形式。"'},"​")],-1),k=e("h3",{id:"_8-杜绝完全不规范的缩写-避免望文不知义。",tabindex:"-1"},[a("8. 杜绝完全不规范的缩写，避免望文不知义。 "),e("a",{class:"header-anchor",href:"#_8-杜绝完全不规范的缩写-避免望文不知义。","aria-label":'Permalink to "8. 杜绝完全不规范的缩写，避免望文不知义。"'},"​")],-1),g=e("h3",{id:"_9-为了达到代码自解释的目标-任何自定义编程元素在命名时-使用尽量完整的单词-组合来表达其意。",tabindex:"-1"},[a("9. 为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词 组合来表达其意。 "),e("a",{class:"header-anchor",href:"#_9-为了达到代码自解释的目标-任何自定义编程元素在命名时-使用尽量完整的单词-组合来表达其意。","aria-label":'Permalink to "9. 为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词 组合来表达其意。"'},"​")],-1),x=e("h3",{id:"_10-如果模块、接口、类、方法使用了设计模式-在命名时体现出具体模式。-说明-将设计模式体现在名字中-有利于阅读者快速理解架构设计理念。",tabindex:"-1"},[a("10. 如果模块、接口、类、方法使用了设计模式，在命名时体现出具体模式。 说明：将设计模式体现在名字中，有利于阅读者快速理解架构设计理念。 "),e("a",{class:"header-anchor",href:"#_10-如果模块、接口、类、方法使用了设计模式-在命名时体现出具体模式。-说明-将设计模式体现在名字中-有利于阅读者快速理解架构设计理念。","aria-label":'Permalink to "10. 如果模块、接口、类、方法使用了设计模式，在命名时体现出具体模式。 说明：将设计模式体现在名字中，有利于阅读者快速理解架构设计理念。"'},"​")],-1),f=e("h3",{id:"_11-接口类中的方法和属性不要加任何修饰符号-public-也不要加-保持代码的简洁-性-并加上有效的javadoc注释。尽量不要在接口里定义变量-如果一定要定义变量-肯定是-与接口方法相关-并且是整个应用的基础常量。",tabindex:"-1"},[a("11. 接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁 性，并加上有效的Javadoc注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是 与接口方法相关，并且是整个应用的基础常量。 "),e("a",{class:"header-anchor",href:"#_11-接口类中的方法和属性不要加任何修饰符号-public-也不要加-保持代码的简洁-性-并加上有效的javadoc注释。尽量不要在接口里定义变量-如果一定要定义变量-肯定是-与接口方法相关-并且是整个应用的基础常量。","aria-label":'Permalink to "11. 接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁 性，并加上有效的Javadoc注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是 与接口方法相关，并且是整个应用的基础常量。"'},"​")],-1),P=e("h3",{id:"_12-接口和实现类的命名有两套规则",tabindex:"-1"},[a("12. 接口和实现类的命名有两套规则： "),e("a",{class:"header-anchor",href:"#_12-接口和实现类的命名有两套规则","aria-label":'Permalink to "12. 接口和实现类的命名有两套规则："'},"​")],-1),q=e("p",null,"1）【强制】对于Service和DAO类，基于SOA的理念，暴露出来的服务一定是接口，内部 的实现类用Impl的后缀与接口区别。",-1),E=e("p",null,"2）【推荐】 如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able的形式）。",-1),T=e("h3",{id:"_13-枚举类名建议带上enum后缀-枚举成员名称需要全大写-单词间用下划线隔开。",tabindex:"-1"},[a("13. 枚举类名建议带上Enum后缀，枚举成员名称需要全大写，单词间用下划线隔开。 "),e("a",{class:"header-anchor",href:"#_13-枚举类名建议带上enum后缀-枚举成员名称需要全大写-单词间用下划线隔开。","aria-label":'Permalink to "13. 枚举类名建议带上Enum后缀，枚举成员名称需要全大写，单词间用下划线隔开。"'},"​")],-1),S=e("p",null,"说明：枚举其实就是特殊的常量类，且构造方法被默认强制是私有。",-1),A=l("",23),C=e("h3",{id:"_2-long或者long初始赋值时-使用大写的l-不能是小写的l-小写容易跟数字1混-淆-造成误解。",tabindex:"-1"},[a("2. long或者Long初始赋值时，使用大写的L，不能是小写的l，小写容易跟数字1混 淆，造成误解。 "),e("a",{class:"header-anchor",href:"#_2-long或者long初始赋值时-使用大写的l-不能是小写的l-小写容易跟数字1混-淆-造成误解。","aria-label":'Permalink to "2. long或者Long初始赋值时，使用大写的L，不能是小写的l，小写容易跟数字1混 淆，造成误解。"'},"​")],-1),D=e("p",null,"说明：Long a = 2l; 写的是数字的21，还是Long型的2?",-1),O=e("h3",{id:"_3-不要使用一个常量类维护所有常量-按常量功能进行归类-分开维护。",tabindex:"-1"},[a("3. 不要使用一个常量类维护所有常量，按常量功能进行归类，分开维护。 "),e("a",{class:"header-anchor",href:"#_3-不要使用一个常量类维护所有常量-按常量功能进行归类-分开维护。","aria-label":'Permalink to "3. 不要使用一个常量类维护所有常量，按常量功能进行归类，分开维护。"'},"​")],-1),v=e("p",null,"说明：大而全的常量类，非得使用查找功能才能定位到修改的常量，不利于理解和维护。",-1),L=e("h3",{id:"_4-常量的复用-应用内共享常量、包-内共享常量、类内共享常量。",tabindex:"-1"},[a("4. 常量的复用：应用内共享常量、包 内共享常量、类内共享常量。 "),e("a",{class:"header-anchor",href:"#_4-常量的复用-应用内共享常量、包-内共享常量、类内共享常量。","aria-label":'Permalink to "4. 常量的复用：应用内共享常量、包 内共享常量、类内共享常量。"'},"​")],-1),I=e("p",null,"1） 应用内共享常量：放置在一方库中，通常是modules中的constant目录下。",-1),w=e("p",null,"在我们项目中：com.sanyi.tools.constant",-1),B=e("p",null,"2） 包内共享常量：即在当前包下单独的constant目录下。",-1),j=e("p",null,"3） 类内共享常量：直接在类内部private static final定义。",-1),M=e("h3",{id:"_5-如果变量值仅在一个范围内变化-且带有名称之外的延伸属性-定义为枚举类。",tabindex:"-1"},[a("5. 如果变量值仅在一个范围内变化，且带有名称之外的延伸属性，定义为枚举类。 "),e("a",{class:"header-anchor",href:"#_5-如果变量值仅在一个范围内变化-且带有名称之外的延伸属性-定义为枚举类。","aria-label":'Permalink to "5. 如果变量值仅在一个范围内变化，且带有名称之外的延伸属性，定义为枚举类。"'},"​")],-1),V=e("p",{"MONDAY(1),":"","TUESDAY(2),":"","WEDNESDAY(3),":"","THURSDAY(4),":"","FRIDAY(5),":"","SATURDAY(6),":"","SUNDAY(7);":""},"public Enum",-1),F=l("",7),J={"css-module":"."},N=l("",5),R=e("p",null,"说明：推荐使用JDK7引入的工具类java.util.Objects#equals(Object a, Object b)",-1),U=e("h3",{id:"_6-bigdecimal的等值比较应使用compareto-方法-而不是equals-方法。",tabindex:"-1"},[a("6,BigDecimal的等值比较应使用compareTo() 方法，而不是equals() 方法。 "),e("a",{class:"header-anchor",href:"#_6-bigdecimal的等值比较应使用compareto-方法-而不是equals-方法。","aria-label":'Permalink to "6,BigDecimal的等值比较应使用compareTo() 方法，而不是equals() 方法。"'},"​")],-1),Y=e("p",null,"说明：equals() 方法会比较值和精度（1.0 与 1.00 返回结果为 false），而compareTo() 则会忽略精度。",-1),z=e("h3",{id:"_7-禁止使用构造方法bigdecimal-double-的方式把double值转化为bigdecimal对象。",tabindex:"-1"},[a("7, 禁止使用构造方法BigDecimal(double) 的方式把double值转化为BigDecimal对象。 "),e("a",{class:"header-anchor",href:"#_7-禁止使用构造方法bigdecimal-double-的方式把double值转化为bigdecimal对象。","aria-label":'Permalink to "7, 禁止使用构造方法BigDecimal(double) 的方式把double值转化为BigDecimal对象。"'},"​")],-1),H=e("p",null,"说明：BigDecimal(double) 存在精度损失风险，在精确计算或值比较的场景中可能会导致业务逻辑异常。",-1),K=e("p",null,"如： BigDecimal g = new BigDecimal(0.1F)；",-1),Q=e("p",null,"实际的存储值为：0.100000001490116119384765625",-1),X=l("",9),G=e("h3",{id:"_9-定义do-po-dto-vo等pojo类时-不要设定任何属性默认值。",tabindex:"-1"},[a("9,定义DO / PO / DTO / VO等POJO类时，不要设定任何属性默认值。 "),e("a",{class:"header-anchor",href:"#_9-定义do-po-dto-vo等pojo类时-不要设定任何属性默认值。","aria-label":'Permalink to "9,定义DO / PO / DTO / VO等POJO类时，不要设定任何属性默认值。"'},"​")],-1),W=l("",9),$=l("",16),Z=e("h3",{id:"_5-禁止在程序中写死一年为365天-避免在公历闰年时出现日期转换错误或程序逻辑错误。",tabindex:"-1"},[a("5.禁止在程序中写死一年为365天，避免在公历闰年时出现日期转换错误或程序逻辑错误。 "),e("a",{class:"header-anchor",href:"#_5-禁止在程序中写死一年为365天-避免在公历闰年时出现日期转换错误或程序逻辑错误。","aria-label":'Permalink to "5.禁止在程序中写死一年为365天，避免在公历闰年时出现日期转换错误或程序逻辑错误。"'},"​")],-1),aa=e("p",null,"// 获取今年的天数",-1),ea=e("p",null,"int daysOfThisYear = LocalDate.now().lengthOfYear();",-1),ta=e("p",null,"// 获取指定某年的天数",-1),sa=e("p",null,"LocalDate.of(2011, 1, 1).lengthOfYear();",-1),ia=l("",9),la=l("",7),oa=e("h3",{id:"_3-【强制】在使用java-util-stream-collectors-类的-tomap-方法转为-map-集合时-一定要使用参数类型-为binaryoperator-参数名为mergefunction-的方法-否则当出现相同key时会抛出-illegalstateexception-异常。",tabindex:"-1"},[a("3.【强制】在使用java.util.stream.Collectors 类的 toMap() 方法转为 Map 集合时，一定要使用参数类型 为BinaryOperator，参数名为mergeFunction 的方法，否则当出现相同key时会抛出 IllegalStateException 异常。 "),e("a",{class:"header-anchor",href:"#_3-【强制】在使用java-util-stream-collectors-类的-tomap-方法转为-map-集合时-一定要使用参数类型-为binaryoperator-参数名为mergefunction-的方法-否则当出现相同key时会抛出-illegalstateexception-异常。","aria-label":'Permalink to "3.【强制】在使用java.util.stream.Collectors 类的 toMap() 方法转为 Map 集合时，一定要使用参数类型 为BinaryOperator，参数名为mergeFunction 的方法，否则当出现相同key时会抛出 IllegalStateException 异常。"'},"​")],-1),ra=e("p",null,"说明：参数mergeFunction的作用是当出现key重复时，自定义对value的处理策略。",-1),na=e("p",null,"List> pairArrayList = new ArrayList<>(3);",-1),ca=e("p",null,'pairArrayList.add(new Pair<>("version", 12.10));',-1),ha=e("p",null,'pairArrayList.add(new Pair<>("version", 12.19));',-1),da=e("p",null,'pairArrayList.add(new Pair<>("version", 6.28));',-1),pa=e("p",null,"// 生成的map集合中只有一个键值对：",-1),_a=e("p",null,"{version=6.28} Map map = pairArrayList.stream() .collect(Collectors.toMap(Pair::getKey, Pair::getValue, (v1, v2) -> v2));",-1),ua=e("p",null,'String[] departments = new String[]{"RDC", "RDC", "KKB"};',-1),ma=e("p",null,"// 抛出IllegalStateException 异常",-1),ba=e("p",null,"Map map = Arrays.stream(departments) .collect(Collectors.toMap(String::hashCode, str -> str));",-1),ya=e("h3",{id:"_4-【强制】在使用java-util-stream-collectors-类的-tomap-方法转为-map-集合时-一定要注意当value-为null-时会抛npe异常。",tabindex:"-1"},[a("4.【强制】在使用java.util.stream.Collectors 类的 toMap() 方法转为 Map 集合时，一定要注意当value 为null 时会抛NPE异常。 "),e("a",{class:"header-anchor",href:"#_4-【强制】在使用java-util-stream-collectors-类的-tomap-方法转为-map-集合时-一定要注意当value-为null-时会抛npe异常。","aria-label":'Permalink to "4.【强制】在使用java.util.stream.Collectors 类的 toMap() 方法转为 Map 集合时，一定要注意当value 为null 时会抛NPE异常。"'},"​")],-1),ka=e("p",null,"说明：",-1),ga=e("p",null,"在java.util.HashMap 的merge方法里会进行如下的判断：",-1),xa=e("p",null,"if (value == null || remappingFunction == null) throw new NullPointerException();",-1),fa=l("",11),Pa=e("h3",{id:"_8-【强制】在sublist-场景中-高度注意对父集合元素的增加或删除-均会导致子列表的遍历、增加、删-除产生concurrentmodificationexception-异常。",tabindex:"-1"},[a("8.【强制】在subList 场景中，高度注意对父集合元素的增加或删除，均会导致子列表的遍历、增加、删 除产生ConcurrentModificationException 异常。 "),e("a",{class:"header-anchor",href:"#_8-【强制】在sublist-场景中-高度注意对父集合元素的增加或删除-均会导致子列表的遍历、增加、删-除产生concurrentmodificationexception-异常。","aria-label":'Permalink to "8.【强制】在subList 场景中，高度注意对父集合元素的增加或删除，均会导致子列表的遍历、增加、删 除产生ConcurrentModificationException 异常。"'},"​")],-1),qa=e("p",null,"说明：抽查表明，90% 的程序员对此知识点都有错误的认知。",-1),Ea=e("h3",{id:"_9-【强制】使用集合转数组的方法-必须使用集合的toarray-t-array-传入的是类型完全一致、长度为-0-的空数组。",tabindex:"-1"},[a("9.【强制】使用集合转数组的方法，必须使用集合的toArray(T[] array)，传入的是类型完全一致、长度为 0 的空数组。 "),e("a",{class:"header-anchor",href:"#_9-【强制】使用集合转数组的方法-必须使用集合的toarray-t-array-传入的是类型完全一致、长度为-0-的空数组。","aria-label":'Permalink to "9.【强制】使用集合转数组的方法，必须使用集合的toArray(T[] array)，传入的是类型完全一致、长度为 0 的空数组。"'},"​")],-1),Ta=l("",21),Sa=e("p",null,"List generics = null;",-1),Aa=e("p",null,"List notGenerics = new ArrayList(10);",-1),Ca=e("p",null,"notGenerics.add(new Object());",-1),Da=e("p",null,"notGenerics.add(new Integer(1));",-1),Oa=e("p",null,"generics = notGenerics; // 此处抛出ClassCastException 异常 String string = generics.get(0);",-1),va=e("h3",{id:"_14-【强制】不要在foreach循环里进行元素的remove-add操作。remove元素请使用iterator方式-如果并发操作-需要对iterator对象加锁。",tabindex:"-1"},[a("14.【强制】不要在foreach循环里进行元素的remove / add操作。remove元素请使用iterator方式， 如果并发操作，需要对iterator对象加锁。 "),e("a",{class:"header-anchor",href:"#_14-【强制】不要在foreach循环里进行元素的remove-add操作。remove元素请使用iterator方式-如果并发操作-需要对iterator对象加锁。","aria-label":'Permalink to "14.【强制】不要在foreach循环里进行元素的remove / add操作。remove元素请使用iterator方式， 如果并发操作，需要对iterator对象加锁。"'},"​")],-1),La=l("",10),Ia=e("p",null,"for (String item : list) {",-1),wa=e("p",null,'if ("1".equals(item)) {',-1),Ba=e("p",null,"list.remove(item);",-1),ja=e("p",null,"}",-1),Ma=e("p",null,"}",-1),Va=e("h3",{id:"_15-【强制】在jdk7版本及以上-comparator实现类要满足如下三个条件-不然arrays-sort-collections-sort-会抛-illegalargumentexception-异常。",tabindex:"-1"},[a("15.【强制】在JDK7版本及以上，Comparator实现类要满足如下三个条件，不然Arrays.sort， Collections.sort 会抛 IllegalArgumentException 异常。 "),e("a",{class:"header-anchor",href:"#_15-【强制】在jdk7版本及以上-comparator实现类要满足如下三个条件-不然arrays-sort-collections-sort-会抛-illegalargumentexception-异常。","aria-label":'Permalink to "15.【强制】在JDK7版本及以上，Comparator实现类要满足如下三个条件，不然Arrays.sort， Collections.sort 会抛 IllegalArgumentException 异常。"'},"​")],-1),Fa=e("p",null,"说明：",-1),Ja=e("p",null,"三个条件如下",-1),Na=e("p",null,"1）x，y的比较结果和y，x的比较结果相反。",-1),Ra=e("p",null,"2）x > y，y > z，则x > z。",-1),Ua=e("p",null,"3）x = y，则x，z比较结果和y，z比较结果相同。",-1),Ya=l("",10),za=l("",5),Ha=e("h3",{id:"_6-【强制】必须回收自定义的threadlocal变量-尤其在线程池场景下-线程经常会被复用-如果不清理-自定义的threadlocal变量-可能会影响后续业务逻辑和造成内存泄露等问题。尽量在代理中使用-try-finally-块进行回收。",tabindex:"-1"},[a("6.【强制】必须回收自定义的ThreadLocal变量，尤其在线程池场景下，线程经常会被复用，如果不清理 自定义的ThreadLocal变量，可能会影响后续业务逻辑和造成内存泄露等问题。尽量在代理中使用 try-finally 块进行回收。 "),e("a",{class:"header-anchor",href:"#_6-【强制】必须回收自定义的threadlocal变量-尤其在线程池场景下-线程经常会被复用-如果不清理-自定义的threadlocal变量-可能会影响后续业务逻辑和造成内存泄露等问题。尽量在代理中使用-try-finally-块进行回收。","aria-label":'Permalink to "6.【强制】必须回收自定义的ThreadLocal变量，尤其在线程池场景下，线程经常会被复用，如果不清理 自定义的ThreadLocal变量，可能会影响后续业务逻辑和造成内存泄露等问题。尽量在代理中使用 try-finally 块进行回收。"'},"​")],-1),Ka=e("p",null,"7.【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就 不要锁整个方法体；能用对象锁，就不要用类锁。 说明：尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用RPC方法。",-1),Qa=e("h3",{id:"_8-【强制】对多个资源、数据库表、对象同时加锁时-需要保持一致的加锁顺序-否则可能会造成死锁。",tabindex:"-1"},[a("8.【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。 "),e("a",{class:"header-anchor",href:"#_8-【强制】对多个资源、数据库表、对象同时加锁时-需要保持一致的加锁顺序-否则可能会造成死锁。","aria-label":'Permalink to "8.【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。"'},"​")],-1),Xa=e("p",null,"说明：线程一需要对表A、B、C依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是A、B、C，否则可 能出现死锁。",-1),Ga=e("h3",{id:"_9-【强制】在使用阻塞等待获取锁的方式中-必须在try代码块之外-并且在加锁方法与try代码块之间没-有任何可能抛出异常的方法调用-避免加锁成功后-在finally中无法解锁。",tabindex:"-1"},[a("9.【强制】在使用阻塞等待获取锁的方式中，必须在try代码块之外，并且在加锁方法与try代码块之间没 有任何可能抛出异常的方法调用，避免加锁成功后，在finally中无法解锁。 "),e("a",{class:"header-anchor",href:"#_9-【强制】在使用阻塞等待获取锁的方式中-必须在try代码块之外-并且在加锁方法与try代码块之间没-有任何可能抛出异常的方法调用-避免加锁成功后-在finally中无法解锁。","aria-label":'Permalink to "9.【强制】在使用阻塞等待获取锁的方式中，必须在try代码块之外，并且在加锁方法与try代码块之间没 有任何可能抛出异常的方法调用，避免加锁成功后，在finally中无法解锁。"'},"​")],-1),Wa=e("h3",{id:"_10-【强制】在使用尝试机制来获取锁的方式中-进入业务代码块之前-必须先判断当前线程是否持有锁。",tabindex:"-1"},[a("10.【强制】在使用尝试机制来获取锁的方式中，进入业务代码块之前，必须先判断当前线程是否持有锁。 "),e("a",{class:"header-anchor",href:"#_10-【强制】在使用尝试机制来获取锁的方式中-进入业务代码块之前-必须先判断当前线程是否持有锁。","aria-label":'Permalink to "10.【强制】在使用尝试机制来获取锁的方式中，进入业务代码块之前，必须先判断当前线程是否持有锁。"'},"​")],-1),$a=l("",7),Za=e("p",null,`如下的代码输出是什么？ public class SwitchString { public static void main(String[] args) { method(null); } public static void method(String param) { switch (param) { // 肯定不是进入这里 case "sth": System.out.println("it's sth"); break; // 也不是进入这里 case "null": System.out.println("it's null"); break; // 也不是进入这里 default: System.out.println("default"); } } }`,-1),ae=e("h3",{id:"_3-【强制】在if-else-for-while-do语句中必须使用大括号。",tabindex:"-1"},[a("3.【强制】在if / else / for / while / do语句中必须使用大括号。 "),e("a",{class:"header-anchor",href:"#_3-【强制】在if-else-for-while-do语句中必须使用大括号。","aria-label":'Permalink to "3.【强制】在if / else / for / while / do语句中必须使用大括号。"'},"​")],-1),ee=e("p",null,"说明：即使只有一行代码，也要采用大括号的编码方式。",-1),te=e("h3",{id:"_4-【强制】三目运算符condition-表达式1-表达式2中-高度注意表达式1和2在类型对齐时-可能-抛出因自动拆箱导致的npe异常。",tabindex:"-1"},[a("4.【强制】三目运算符condition ? 表达式1：表达式2中，高度注意表达式1和2在类型对齐时，可能 抛出因自动拆箱导致的NPE异常。 "),e("a",{class:"header-anchor",href:"#_4-【强制】三目运算符condition-表达式1-表达式2中-高度注意表达式1和2在类型对齐时-可能-抛出因自动拆箱导致的npe异常。","aria-label":'Permalink to "4.【强制】三目运算符condition ? 表达式1：表达式2中，高度注意表达式1和2在类型对齐时，可能 抛出因自动拆箱导致的NPE异常。"'},"​")],-1),se=e("p",null,"说明：以下两种场景会触发类型对齐的拆箱操作：",-1),ie=e("p",null,"1）表达式1或 表达式2的值只要有一个是原始类型。",-1),le=e("p",null,"2）表达式1或 表达式2的值的类型不一致，会强制拆箱升级成表示范围更大的那个类型。",-1),oe=e("p",null,"Integer a = 1;",-1),re=e("p",null,"Integer b = 2;",-1),ne=e("p",null,"Integer c = null;",-1),ce=e("p",null,"Boolean flag = false;",-1),he=e("p",null,"// a*b 的结果是int类型，那么c会强制拆箱成int类型，抛出NPE异常 Integer result = (flag ? a * b : c);",-1),de=e("h3",{id:"_5-【强制】在并发场景中-避免使用-等于-判断作为中断或退出的条件。",tabindex:"-1"},[a("5.【强制】在并发场景中，避免使用“等于”判断作为中断或退出的条件。 "),e("a",{class:"header-anchor",href:"#_5-【强制】在并发场景中-避免使用-等于-判断作为中断或退出的条件。","aria-label":'Permalink to "5.【强制】在并发场景中，避免使用“等于”判断作为中断或退出的条件。"'},"​")],-1),pe=e("p",null,"说明：",-1),_e=e("p",null,"如果并发控制没有处理好，容易产生等值判断被“击穿”的情况，使用大于或小于的区间判断条件来代替。",-1),ue=l("",21),me=l("",21),be=e("p",null,"Map map = new HashMap<>(16);",-1),ye=e("p",null,'map.put("start", start);',-1),ke=e("p",null,'map.put("size", size);',-1),ge=e("h3",{id:"_6-【强制】不允许直接拿hashmap与hashtable作为查询结果集的输出。",tabindex:"-1"},[a("6.【强制】不允许直接拿HashMap与Hashtable作为查询结果集的输出。 "),e("a",{class:"header-anchor",href:"#_6-【强制】不允许直接拿hashmap与hashtable作为查询结果集的输出。","aria-label":'Permalink to "6.【强制】不允许直接拿HashMap与Hashtable作为查询结果集的输出。"'},"​")],-1),xe=l("",32);function fe(Pe,qe,Ee,Te,Se,Ae){const t=r("font");return c(),n("div",null,[d,s(t,{style:{color:"#5C8D07"}},{default:i(()=>[a("正例：")]),_:1}),a("MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion "),s(t,{style:{color:"#E4495B"}},{default:i(()=>[a("反例：")]),_:1}),a("macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion "),p,s(t,{style:{color:"#5C8D07"}},{default:i(()=>[a("正例：")]),_:1}),a(" localValue / getHttpMessage() / inputUserId "),_,s(t,{style:{color:"#5C8D07"}},{default:i(()=>[a("正例：")]),_:1}),a("MAX_STOCK_COUNT "),s(t,{style:{color:"#E4495B"}},{default:i(()=>[a("反例：")]),_:1}),a("MAX_COUNT "),u,m,s(t,{style:{color:"#E4495B"}},{default:i(()=>[a("反例：")]),_:1}),a("使用String args[]的方式来定义。 "),b,s(t,{style:{color:"#E4495B"}},{default:i(()=>[a(" 反例：")]),_:1}),a("定义为基本数据类型Boolean isDeleted；的属性，它的方法也是isDeleted() 框架在反向解析的时候，“以为”对应的属性名称是deleted，导致属性获取不到，进而抛出异常。 "),y,s(t,{style:{color:"#5C8D07"}},{default:i(()=>[a("正例： ")]),_:1}),a("应用工具类包名为com.sanyi.util、类名为MessageUtils（此规则参考 spring 的框架结构） "),k,s(t,{style:{color:"#E4495B"}},{default:i(()=>[a("反例：")]),_:1}),a("AbstractClass“缩写”命名成AbsClass；condition“缩写”命名成 condi，此类随 意缩写严重降低了代码的可阅读性。 "),g,s(t,{style:{color:"#5C8D07"}},{default:i(()=>[a("正例：")]),_:1}),a("从远程仓库拉取代码的类命名为PullCodeFromRemoteRepository。"),s(t,{style:{color:"#E4495B"}},{default:i(()=>[a("反例：")]),_:1}),a("变量int a; 的随意命名方式。 "),x,s(t,{style:{color:"#5C8D07"}},{default:i(()=>[a("正例：")]),_:1}),a("public class OrderFactory; public class LoginProxy; public class ResourceObserver; "),f,s(t,{style:{color:"#5C8D07"}},{default:i(()=>[a("正例：")]),_:1}),a('接口方法签名：void f(); 接口基础常量表示：String COMPANY = "sanyi";'),s(t,{style:{color:"#E4495B"}},{default:i(()=>[a("反例：")]),_:1}),a("接口方法定义：public abstract void f(); 说明：JDK8中接口允许有默认实现，那么这个default方法，是对所有实现类都有价值的默 认实现。 "),P,q,s(t,{style:{color:"#5C8D07"}},{default:i(()=>[a("正例：")]),_:1}),a("CacheServiceImpl实现CacheService接口。"),E,s(t,{style:{color:"#5C8D07"}},{default:i(()=>[a("正例：")]),_:1}),a("AbstractTranslator实现 Translatable。 "),T,S,s(t,{style:{color:"#5C8D07"}},{default:i(()=>[a("正例：")]),_:1}),a("枚举名字为ProcessStatusEnum的成员名称：SUCCESS / UNKOWN_REASON。 "),A,s(t,{style:{color:"#E4495B"}},{default:i(()=>[a("反例：")]),_:1}),a('String key = "Id#taobao_" + tradeId; cache.put(key, value); '),C,D,O,v,s(t,{style:{color:"#5C8D07"}},{default:i(()=>[a("正例：")]),_:1}),a("缓存相关常量放在类CacheConsts下；系统配置相关常量放在类ConfigConsts下。"),L,I,s(t,{style:{color:"#E4495B"}},{default:i(()=>[a("反例：")]),_:1}),a('易懂变量也要统一定义成应用内共享常量，两位攻城师在两个类中分别定义了表示 “是”的变量： 类A中：public static final String YES = "yes"; 类B中：public static final String YES = "y"; A.YES.equals(B.YES)，预期是true，但实际返回为false，导致线上问题。 '),w,B,j,M,e("p",null,[a("下面 "),s(t,{style:{color:"#5C8D07"}},{default:i(()=>[a("正例")]),_:1}),a("中的数字就是延伸信息，表示星期几。")]),s(t,{style:{color:"#5C8D07"}},{default:i(()=>[a("正例：")]),_:1}),V,F,e("p",J,[a("说明：可变参数必须放置在参数列表的最后。（建议开发者尽量不用可变参数编程） "),s(t,{style:{color:"#5C8D07"}},{default:i(()=>[a("正例：")]),_:1}),a("public List listUsers(String type, Long... ids)")]),N,s(t,{style:{color:"#5C8D07"}},{default:i(()=>[a(" 正例：")]),_:1}),a('"test".equals(param);'),s(t,{style:{color:"#E4495B"}},{default:i(()=>[a(" 反例：")]),_:1}),a('param.equals("test"); '),R,U,Y,z,H,K,Q,s(t,{style:{color:"#5C8D07"}},{default:i(()=>[a("正例：")]),_:1}),X,s(t,{style:{color:"#5C8D07"}},{default:i(()=>[a("正例：")]),_:1}),a("数据库的查询结果可能是null，因为自动拆箱，用基本数据类型接收有NPE风险。"),s(t,{style:{color:"#E4495B"}},{default:i(()=>[a("反例：")]),_:1}),a("某业务的报表上显示成交涨跌情况，即正负x%，x为基本数据类型，调用的RPC服务，调用不成功时， 返回的是默认值，页面显示为0%，这是不合理的，应该显示成中划线-。所以包装数据类型的null值，能够表示额外的 信息，如：远程调用失败，异常退出。 "),G,s(t,{style:{color:"#E4495B"}},{default:i(()=>[a("反例：")]),_:1}),a("某业务的DO的createTime默认值为new Date()；但是这个属性在数据提取时并没有置入具体值，在更新其 它字段时又附带更新了此字段，导致创建时间被修改成当前时间。 "),W,s(t,{style:{color:"#5C8D07"}},{default:i(()=>[a("正例：")]),_:1}),a('表示日期和时间的格式如下所示： new SimpleDateFormat("yyyy-MM-dd HH:mm:ss") '),s(t,{style:{color:"#E4495B"}},{default:i(()=>[a("反例：")]),_:1}),a("某程序员因使用YYYY/MM/dd进行日期格式化，2017/12/31执行结果为2018/12/31，造成线上故障。 "),$,s(t,{style:{color:"#E4495B"}},{default:i(()=>[a(" 反例：")]),_:1}),a("java.util.Date.after(Date) 进行时间比较时，当入参是java.sql.Timestamp 时，会触发JDK BUG（JDK9已修 复），可能导致比较时的意外结果。 "),Z,s(t,{style:{color:"#5C8D07"}},{default:i(()=>[a(" 正例：")]),_:1}),aa,ea,ta,sa,s(t,{style:{color:"#E4495B"}},{default:i(()=>[a("反例：")]),_:1}),ia,s(t,{style:{color:"#5C8D07"}},{default:i(()=>[a("正例：")]),_:1}),a("Calendar.JANUARY，Calendar.FEBRUARY，Calendar.MARCH 等来指代相应月份来进行传参或比较。 "),la,s(t,{style:{color:"#5C8D07"}},{default:i(()=>[a("正例：")]),_:1}),a(' Map map = new HashMap<>(16); if (map.isEmpty()) { System.out.println("no element in this map."); } '),oa,ra,s(t,{style:{color:"#5C8D07"}},{default:i(()=>[a("正例：")]),_:1}),na,ca,ha,da,pa,_a,s(t,{style:{color:"#E4495B"}},{default:i(()=>[a("反例： ")]),_:1}),ua,ma,ba,ya,ka,ga,xa,s(t,{style:{color:"#E4495B"}},{default:i(()=>[a("反例：")]),_:1}),fa,s(t,{style:{color:"#E4495B"}},{default:i(()=>[a("反例：")]),_:1}),a("如果查询无结果，返回Collections.emptyList() 空集合对象，调用方一旦在返回的集合中进行了添加元素的操 作，就会触发UnsupportedOperationException 异常。 "),Pa,qa,Ea,s(t,{style:{color:"#E4495B"}},{default:i(()=>[a("反例：")]),_:1}),a("直接使用toArray无参方法存在问题，此方法返回值只能是Object[]类，若强转其它类型数组将出现 ClassCastException 错误。"),s(t,{style:{color:"#5C8D07"}},{default:i(()=>[a("正例：")]),_:1}),Ta,s(t,{style:{color:"#E4495B"}},{default:i(()=>[a(" 反例：")]),_:1}),Sa,Aa,Ca,Da,Oa,va,s(t,{style:{color:"#5C8D07"}},{default:i(()=>[a(" 正例：")]),_:1}),La,s(t,{style:{color:"#E4495B"}},{default:i(()=>[a("反例：")]),_:1}),Ia,wa,Ba,ja,Ma,e("p",null,[a("说明："),s(t,{style:{color:"#E4495B"}},{default:i(()=>[a("反例")]),_:1}),a("中的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”会是同样的结果吗？")]),Va,Fa,Ja,Na,Ra,Ua,s(t,{style:{color:"#E4495B"}},{default:i(()=>[a("反例：")]),_:1}),Ya,s(t,{style:{color:"#5C8D07"}},{default:i(()=>[a("正例：")]),_:1}),a(`自定义线程工厂，并且根据外部特征进行分组，比如，来自同一机房的调用，把机房编号赋值给 whatFeatureOfGroup： public class UserThreadFactory implements ThreadFactory { private final String namePrefix; private final AtomicInteger nextId = new AtomicInteger(1); // 定义线程组名称，在利用jstack来排查问题时，非常有帮助 UserThreadFactory(String whatFeatureOfGroup) { namePrefix = "FromUserThreadFactory's" + whatFeatureOfGroup + "-Worker-"; } @Override public Thread newThread(Runnable task) { String name = namePrefix + nextId.getAndIncrement(); Thread thread = new Thread(null, task, name, 0, false); System.out.println(thread.getName()); return thread; } } `),za,s(t,{style:{color:"#5C8D07"}},{default:i(()=>[a("正例：")]),_:1}),a('注意线程安全，使用DateUtils。亦推荐如下处理： private static final ThreadLocal dateStyle = new ThreadLocal() { @Override protected DateFormat initialValue() { return new SimpleDateFormat("yyyy-MM-dd"); } }; 说明：如果是JDK8的应用，可以使用Instant代替Date，LocalDateTime代替Calendar，DateTimeFormatter代替 SimpleDateFormat，官方给出的解释：simple beautiful strong immutable thread-safe。 '),Ha,s(t,{style:{color:"#5C8D07"}},{default:i(()=>[a("正例：")]),_:1}),a(" objectThreadLocal.set(userInfo); try { // ... } finally { objectThreadLocal.remove(); } "),Ka,Qa,Xa,Ga,e("p",null,[a("说明一：在lock方法与try代码块之间的方法调用抛出异常，无法解锁，造成其它线程无法成功获取锁。 说明二：如果lock方法在try代码块之内，可能由于其它方法抛出异常，导致在finally代码块中，unlock对未加锁的对 象解锁，它会调用AQS的tryRelease方法（取决于具体实现类），抛出IllegalMonitorStateException异常。 说明三：在Lock对象的lock方法实现中可能抛出unchecked异常，产生的后果与说明二相同。"),s(t,{style:{color:"#5C8D07"}})]),s(t,{style:{color:"#5C8D07"}},{default:i(()=>[a("正例：")]),_:1}),a(" Lock lock = new XxxLock(); // ... lock.lock(); try { doSomething(); doOthers(); } finally { lock.unlock(); } "),s(t,{style:{color:"#E4495B"}},{default:i(()=>[a("反例：")]),_:1}),a(" Lock lock = new XxxLock(); // ... try { // 如果此处抛出异常，则直接执行finally代码块 doSomething(); // 无论加锁是否成功，finally代码块都会执行 lock.lock(); doOthers(); } finally { lock.unlock(); } "),Wa,e("p",null,[a("锁的释放规则与锁的阻塞等待方式相同。 说明：Lock对象的unlock方法在执行时，它会调用AQS的tryRelease方法（取决于具体实现类），如果当前线程不 持有锁，则抛出IllegalMonitorStateException 异常。"),s(t,{style:{color:"#5C8D07"}},{default:i(()=>[a(" 正例：")]),_:1}),a(" Lock lock = new XxxLock(); // ... boolean isLocked = lock.tryLock(); if (isLocked) { try { doSomething(); doOthers(); } finally { lock.unlock(); } }")]),$a,s(t,{style:{color:"#E4495B"}},{default:i(()=>[a(" 反例：")]),_:1}),Za,ae,s(t,{style:{color:"#E4495B"}},{default:i(()=>[a("反例：")]),_:1}),a(" if (condition) statements; "),ee,te,se,ie,le,s(t,{style:{color:"#E4495B"}},{default:i(()=>[a(" 反例：")]),_:1}),oe,re,ne,ce,he,de,pe,_e,s(t,{style:{color:"#E4495B"}},{default:i(()=>[a("反例：")]),_:1}),ue,s(t,{style:{color:"#5C8D07"}},{default:i(()=>[a(" 正例：")]),_:1}),me,s(t,{style:{color:"#5C8D07"}},{default:i(()=>[a("正例：")]),_:1}),be,ye,ke,ge,s(t,{style:{color:"#E4495B"}},{default:i(()=>[a("反例：")]),_:1}),a("为避免写一个xxx，直接使用Hashtable来接收数据库返回结果，结果出现 日常是把bigint转成Long值，而线上由于数据库版本不一样，解析成BigInteger，导致线上问题。"),xe])}const Oe=o(h,[["render",fe]]);export{De as __pageData,Oe as default};
